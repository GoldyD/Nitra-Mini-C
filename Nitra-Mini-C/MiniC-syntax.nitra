syntax module MiniCSyntax
{
  using Nitra.Core;
  using Nitra.CStyleComments;

  keyword regex ['a'..'z', '_'..'_']+ rule S;
  regex KeywordToken = "if" | "else" | "while" | "return" | "break" | "void" | "int" | "true" | "false" | "bool" | "float";

  [Keyword] token Keyword = Name=KeywordToken !IdentifierPartCharacters;
  [Reference] token Reference = !Keyword IdentifierBody;
  [Name] token Name = !Keyword IdentifierBody;

  regex DecimalDigit = ['0'..'9'];
  
  [StartRule]
  syntax CompilationUnit = (Statement nl)*;

  syntax Statement
  {
	| Declaration = Declaration
	| Expression = Expression
  }

  syntax VariableDeclaration = Type Name ";";

  syntax Declaration
  {  
	| VariableDeclaration = VariableDeclaration;
	//| FunctionDeclaration = Type sm Name "(" VariableDeclaration* ")" Body;
  }

  syntax Type
  {
    | Void = "void" sm;
	| Int = "int" sm;
	| Float = "float" sm;
	| Bool = "bool" sm;
  }

  syntax Body
  {
    | Block = nl "{" inl Expression* d "}" ";"? nl;
    | Empty = ";" nl;
  }

  syntax Expression
  {
    | [SpanClass(Number)] IntegerLiteral = Digits
      {
        regex Digits = DecimalDigit+;
      }
	| [SpanClass(Number)] FloatLiteral = Digits
      {
        regex Digits = DecimalDigit+ "." DecimalDigit+;
      }
	| [SpanClass(Type)] BooleanLiteral = TrueFalse
	  {
		regex TrueFalse = "true" | "false";
	  }
    | Parenthesized = "(" Expression ")";
    | Variable = Reference;

	precedence Assignment:
    | Assignment             = Reference sm "=" sm Expression ";" right-associative;

    precedence ConditionalOR:
    | ConditionalOr          = Expression sm "||" sm Expression;

    precedence ConditionalAND:
    | ConditionalAnd         = Expression sm "&&" sm Expression;

    precedence RelationalAndTypeTesting:
    | LessThan               = Expression sm "<"  sm Expression;
    | GreaterThan            = Expression sm ">"  sm Expression;
    | LessThanOrEqual        = Expression sm "<=" sm Expression;
    | GreaterThanOrEqual     = Expression sm ">=" sm Expression;

    precedence Additive:
    | Add                    = Expression sm "+"  sm Expression;
    | Sub                    = Expression sm "-"  sm Expression;

    precedence Multiplicative:
    | Mul                    = Expression sm "*"  sm Expression;
    | Div                    = Expression sm "/"  sm Expression;
    | Remainder              = Expression sm "%"  sm Expression;

    precedence Unary:
    | Identity               = "+"  Expression;
    | Negation               = "-"  Expression;
    | LogicalNegation        = "!"  Expression;
  }
}