using Nitra;
using Nitra.Declarations;
using System.Linq;
using System.Collections.Generic;

namespace MiniC
{
  ast CompilationUnit
  {
    in ContainingTable: TableScope;
    TopDeclarations.ContainingTable = ContainingTable;
    TopDeclarations: TopDeclaration*;
  }

  abstract declaration TopDeclaration
  {
  }
  
  abstract declaration VarDeclaration: TopDeclaration 
  {
    symbol
    {
      in Type: TypeSymbol;

      SpanClass = MiniC.VariableSpanClass;
      Kind = "variable";
    }

    Symbol.Type = TypeRef.Type;

    TypeRef : TypeReference;

    | ScalarDeclaration {}
    | ArrayDeclaration {}
  }
  
  declaration FunDeclaration: TopDeclaration 
  {
    symbol 
    {
      in ReturnType      : TypeSymbol;
      in Parameters      : IList[VarDeclarationSymbol];
      in FunScope        : Scope;
      out ParameterScope : TableScope = TableScope("parameters", this);
      SpanClass = MiniC.FunctionSpanClass;
      Kind      = "function";
    }

    Symbol.ReturnType          = ReturnTypeRef.Type;
    Parameters.ContainingTable = Symbol.ParameterScope;
    Symbol.FunScope            = ContainingTable.HideWith(Symbol.ParameterScope);
    Symbol.Parameters          = Parameters.Symbol.ToList();
    Body.DeclaredIn            = Symbol;
    Body.OuterScope            = Symbol.FunScope;

    ReturnTypeRef : TypeReference;
    Parameters    : VarDeclaration*;
    Body          : CompoundStatement;
  }

  ast CompoundStatement: BindableAst
  {
    in OuterScope : Scope;
    in DeclaredIn : DeclarationSymbol;
    out LocalVariableScope: TableScope = TableScope("local variables", DeclaredIn);

    LocalVariables.ContainingTable = LocalVariableScope;
    Scope = OuterScope.HideWith(LocalVariableScope);
    Statements.Scope = Scope;

    LocalVariables : VarDeclaration*;
    Statements     : Statement*;
  }

  abstract ast Statement: BindableAst
  {
    | Empty {}
    | Expression 
      { 
        Body.Scope = Scope;
        Body: Expr;
      }
    | Compound { Nested: CompoundStatement; }
    | If 
      {
        Condition.Scope = Scope;
        TrueBranch.Scope  = Scope;
        FalseBranch.Scope = Scope;

        Condition: Expr;
        TrueBranch  : Statement;
        FalseBranch : Statement;
      }
    | While 
      {
        Condition.Scope = Scope;
        Body.Scope = Scope;

        Condition: Expr;
        Body: Statement;
      }
    | ReturnVoid {}
    | Return { Value: Expr; }
    | Break {}
  }

  abstract ast Unary  : Expr 
  { 
    Expr1.Scope = Scope;
    Expr1 : Expr; 
  }
  
  abstract ast Binary : Expr
  { 
    Expr1.Scope = Scope;
    Expr2.Scope = Scope;
    Expr1 : Expr;
    Expr2 : Expr; 
  }

  abstract ast Expr: BindableAst
  {
    | IntegerLiteral { Value : int; }
    | FloatLiteral   { Value : double; }
    | FalseLiteral   { }
    | TrueLiteral    { }
    | VariableRef 
      {
        out Ref: Ref[VarDeclaration.ScalarDeclarationSymbol] = Reference.Ref.Resolve();
        Reference.Scope = Scope;
        Reference: Reference;
      }
    | ArrayRef 
      {
        out Ref: Ref[VarDeclaration.ArrayDeclarationSymbol] = Reference.Ref.Resolve();
        Reference.Scope = Scope;
        Index.Scope = Scope;
        
        Reference: Reference;
        Index: Expr;
      }
    | FunCall 
      {
        out Ref: Ref[FunDeclarationSymbol] = Reference.Ref.Resolve();
        Reference.Scope = Scope;
        Arguments.Scope = Scope;

        Arguments: Expr*;
        Reference: Reference;
      }
    | ArraySize 
      {
        out Ref: Ref[VarDeclaration.ArrayDeclarationSymbol] = Reference.Ref.Resolve();
        Reference.Scope = Scope;

        Reference: Reference;
      }

    | ArrayAllocation 
      {
        in Type: TypeSymbol = TypeRef.Type;
        Size.Scope = Scope;

        TypeRef: TypeReference;
        Size: Expr;
      }
    | ScalarAssignment
      {
        out Ref: Ref[VarDeclarationSymbol] = Reference.Ref.Resolve();
        Reference.Scope = Scope;
        Value.Scope = Scope;

        Reference: Reference;
        Value: Expr;
      }
    | ArrayAssignment
      {
        out Ref: Ref[VarDeclaration.ArrayDeclarationSymbol] = Reference.Ref.Resolve();
        Reference.Scope = Scope;
        Index.Scope = Scope;
        Value.Scope = Scope;

        Reference: Reference;
        Index: Expr;
        Value: Expr;
      }

    | Or           : Binary { }
    | And          : Binary { }
    | Equal        : Binary { }
    | NotEqual     : Binary { }
    | LessEqual    : Binary { }
    | Less         : Binary { }
    | GreaterEqual : Binary { }
    | Greater      : Binary { }
    | Sum          : Binary { }
    | Sub          : Binary { }
    | Modulus      : Binary { }
    | Multiply     : Binary { }
    | Divide       : Binary { }

    | Plus          : Unary { }
    | Minus         : Unary { }
    | Negate        : Unary { }
    | LogicalNegate : Unary { }
  }

  abstract ast TypeReference 
  {
    in Type: TypeSymbol;

    | Void  { Type = context.GetVoidSymbol(); }
    | Int   { Type = context.GetIntSymbol(); }
    | Float { Type = context.GetFloatSymbol(); }
    | Bool  { Type = context.GetBoolSymbol(); }
  }

  declaration Root : Container {}

  declaration Void  : Type {}
  declaration Int   : Type {}
  declaration Float : Type {}
  declaration Bool  : Type {}
}