using Nitra;
using Nitra.Declarations;
using System.Linq;
using System.Collections.Generic;

namespace MiniC
{
  ast CompilationUnit
  {
    in ContainingTable: TableScope;
    TopDeclarations.ContainingTable = ContainingTable;
    TopDeclarations: TopDeclaration*;
  }

  abstract declaration TopDeclaration
  {
  }
  
  abstract declaration VarDeclaration: TopDeclaration 
  {
    symbol
    {
      in Type: TypeSymbol;

      SpanClass = MiniC.VariableSpanClass;
      Kind = "variable";
    }

    Symbol.Type = TypeRef.Type;

    TypeRef : TypeReference;

    | ScalarDeclaration {}
    | ArrayDeclaration {}
  }
  
  declaration FunDeclaration: TopDeclaration 
  {
    symbol 
    {
      in ReturnType : TypeSymbol;
      in Parameters : IList[VarDeclarationSymbol];
      out ParameterScope : TableScope = TableScope("parameters", this);
      SpanClass = MiniC.FunctionSpanClass;
      Kind = "function";
    }

    Symbol.ReturnType          = ReturnTypeRef.Type;
    Parameters.ContainingTable = Symbol.ParameterScope;
    Symbol.Scope               = ContainingTable.HideWith(Symbol.ParameterScope);
    Symbol.Parameters          = Parameters.Symbol.ToList();
    Body.DeclaredIn            = Symbol;
    Body.OuterScope            = Symbol.Scope;

    ReturnTypeRef     : TypeReference;
    Parameters        : VarDeclaration*;
    Body : CompoundStatement;
  }

  ast CompoundStatement: BindableAst
  {
    in OuterScope : Scope;
    in DeclaredIn : FunDeclarationSymbol;
    out LocalVariableScope: TableScope = TableScope("local variables", DeclaredIn);

    LocalVariables.ContainingTable = LocalVariableScope;
    Scope = OuterScope.HideWith(LocalVariableScope);
	Statements.Scope = Scope;

    LocalVariables: VarDeclaration*;
    Statements: Statement*;
  }

  abstract ast Statement: BindableAst
  {
    | Expr 
      { 
        //Expr: Expr; 
      }
    | Compound { Nested: CompoundStatement; }
    | If 
      {
        Condition.Scope = Scope;
        TrueBranch.Scope = Scope;
        FalseBranch.Scope = Scope;

        Condition: Expr;
        TrueBranch: Statement;
        FalseBranch: Statement;
      }
    | While 
      {
        Condition.Scope = Scope;
        Body.Scope = Scope;

        Condition: Expr;
        Body: Statement;
      }
    | Return 
      { 
        //Value: Expr; 
      }
    | Break {}
  }

  abstract ast Expr: BindableAst
  {
    | IntegerLiteral { Value: int; }
    | FloatLiteral { Value: double; }
    | BoolLiteral { Value: bool; }
    | VariableRef 
      {
        out Ref: Ref[VarDeclarationSymbol] = Reference.Ref.Resolve;
        Reference.Scope = Scope;
        Reference: Reference;
      }
    | ArrayRef 
      {
        out Ref: Ref[VarDeclarationSymbol] = Reference.Ref.Resolve();
        Reference.Scope = Scope;
        Index.Scope = Scope;
        
        Reference: Reference;
        Index: Expr;
      }
    | FunCall 
      {
        out Ref: Ref[FunDeclarationSymbol] = Reference.Ref.Resolve();
        Reference.Scope = Scope;
        Arguments.Scope = Scope;

        Arguments: Expr*;
        Reference: Reference;
      }
    | ArraySize 
      {
        out Ref: Ref[ArrayDeclarationSymbol] = Reference.Ref.Resolve();
        Reference.Scope = Scope;

        Reference: Reference;
      }
    | Braces { Expr: Expr; }
    | ArrayAllocation 
      {
        in Type: TypeSymbol = TypeRef.Type;
        Size.Scope = Scope;

        TypeRef: TypeReference;
        Size: Expr;
      }
    | ScalarAssignment
      {
        out Ref: Ref[VarDeclarationSymbol] = Reference.Ref.Resolve();
        Reference.Scope = Scope;
        Value.Scope = Scope;

        Reference: Reference;
        Value: Expr;
      }
    | ArrayAssignment
      {
        out Ref: Ref[ArrayDeclarationSymbol] = Reference.Ref.Resolve();
        Reference.Scope = Scope;
        Index.Scope = Scope;
        Value.Scope = Scope;

        Reference: Reference;
        Index: Expr;
        Value: Expr;
      }
  }

  abstract ast TypeReference 
  {
    in Type: TypeSymbol;

    | Void  { Type = context.GetVoidSymbol(); }
    | Int   { Type = context.GetIntSymbol(); }
    | Float { Type = context.GetFloatSymbol(); }
    | Bool  { Type = context.GetBoolSymbol(); }
  }

  declaration Root : Container {}

  declaration Void  : Type {}
  declaration Int   : Type {}
  declaration Float : Type {}
  declaration Bool  : Type {}
}