using Nitra;
using Nitra.Declarations;
using System.Linq;
using System.Collections.Generic;

namespace MiniC
{
  ast CompilationUnit
  {
    in ContainingTable: TableScope;
    TopDeclarations.ContainingTable = ContainingTable;
    TopDeclarations: TopDeclaration*;
  }

  abstract declaration TopDeclaration
  {
  }
  
  abstract declaration VarDeclaration: TopDeclaration 
  {
    symbol
    {
      in Type: TypeSymbol;

      SpanClass = MiniC.VariableSpanClass;
      Kind = "variable";
    }

    Symbol.Type = TypeRef.Type;

    TypeRef : TypeReference;

    | ScalarDeclaration {}
    | ArrayDeclaration {}
  }
  
  abstract ast LocalVariableContainer
  {
    in DeclaredIn : DeclarationSymbol;
    in Loop       : option[Statement.While] = None();
  }

  declaration FunDeclaration: TopDeclaration 
  {
    symbol 
    {
      in ReturnType      : TypeSymbol;
      in Parameters      : IList[VarDeclarationSymbol];
      in FunScope        : Scope;
      out ParameterScope : TableScope = TableScope("parameters", this);
      SpanClass = MiniC.FunctionSpanClass;
      Kind      = "function";
    }

    Symbol.ReturnType          = ReturnTypeRef.Type;
    Parameters.ContainingTable = Symbol.ParameterScope;
    Symbol.FunScope            = ContainingTable.HideWith(Symbol.ParameterScope);
    Symbol.Parameters          = Parameters.Symbol.ToList();
    Body.DeclaredIn            = Symbol;
    Body.OuterScope            = Symbol.FunScope;

    ReturnTypeRef : TypeReference;
    Parameters    : VarDeclaration*;
    Body          : CompoundStatement;
  }

  ast CompoundStatement: BindableAst, LocalVariableContainer
  {
    in OuterScope : Scope;
    out LocalVariableScope: TableScope = TableScope("local variables", DeclaredIn);

    LocalVariables.ContainingTable = LocalVariableScope;
    Scope = OuterScope.HideWith(LocalVariableScope);
    Statements.Scope = Scope;
    Statements.DeclaredIn = DeclaredIn;
    Statements.Loop = Loop;

    LocalVariables : VarDeclaration*;
    Statements     : Statement*;
  }

  abstract ast Statement: BindableAst, LocalVariableContainer
  {
    | Empty {}
    | Expression 
      { 
        Body.Scope = Scope;
        Body: Expr;
      }
    | Compound 
      { 
        Nested.OuterScope = Scope;
        Nested.DeclaredIn = DeclaredIn;
        Nested.Loop = Loop;

        Nested : CompoundStatement; 
      }
    | If 
      {
        Condition.Scope = Scope;
        TrueBranch.Scope  = Scope;
        FalseBranch.Scope = Scope;
        TrueBranch.DeclaredIn = DeclaredIn;
        FalseBranch.DeclaredIn = DeclaredIn;
        TrueBranch.Loop = Loop;
        FalseBranch.Loop = Loop;

        Condition: Expr;
        TrueBranch  : Statement;
        FalseBranch : Statement;
      }
    | While 
      {
        Condition.Scope = Scope;
        Body.Scope = Scope;
        Body.DeclaredIn = DeclaredIn;
        Body.Loop = Some(this);

        Condition: Expr;
        Body: Statement;
      }
    | ReturnVoid {}
    | Return 
      { 
        Value.Scope = Scope;
        Value: Expr; 
      }
    | Break {}
  }

  abstract ast Unary : Expr 
  { 
    Expr1.Scope = Scope;
    Expr1 : Expr; 
  }
  
  abstract ast Binary : Expr
  { 
    Expr1.Scope = Scope;
    Expr2.Scope = Scope;
    Expr1 : Expr;
    Expr2 : Expr; 
  }

  abstract ast BoolExpr : Binary
  {
     Type = context.GetBoolSymbol();
  }

  abstract ast Expr: BindableAst
  {
    in Type: DeclarationSymbol = context.GetVoidSymbol();

    | IntegerLiteral 
      { 
        Type = context.GetIntSymbol();
        Value : int; 
      }
    | FloatLiteral   
      { 
        Type = context.GetFloatSymbol();
        Value : double; 
      }
    | FalseLiteral { Type = context.GetBoolSymbol(); }
    | TrueLiteral { Type = context.GetBoolSymbol(); }
    | VariableRef 
      {
        out Ref: Ref[VarDeclaration.ScalarDeclarationSymbol] = Reference.Ref.Resolve();
        Reference.Scope = Scope;
        Type = Ref.Symbol.Type;
        
        Reference: Reference;
      }
    | ArrayRef 
      {
        out Ref: Ref[VarDeclaration.ArrayDeclarationSymbol] = Reference.Ref.Resolve();
        Reference.Scope = Scope;
        Index.Scope = Scope;
        Type = Ref.Symbol.Type;
        
        Reference: Reference;
        Index: Expr;
      }
    | FunCall 
      {
        out Ref: Ref[FunDeclarationSymbol] = Reference.Ref.Resolve();
        Reference.Scope = Scope;
        Arguments.Scope = Scope;
        Type = Ref.Symbol.ReturnType;

        Arguments: Expr*;
        Reference: Reference;
      }
    | ArraySize 
      {
        out Ref: Ref[VarDeclaration.ArrayDeclarationSymbol] = Reference.Ref.Resolve();
        Reference.Scope = Scope;
        Type = context.GetIntSymbol();

        Reference: Reference;
      }

    | ArrayAllocation 
      {
        Type = TypeRef.Type;
        Size.Scope = Scope;

        TypeRef: TypeReference;
        Size: Expr;
      }
    | ScalarAssignment
      {
        out Ref: Ref[VarDeclarationSymbol] = Reference.Ref.Resolve();
        Reference.Scope = Scope;
        Value.Scope = Scope;

        Reference: Reference;
        Value: Expr;
      }
    | ArrayAssignment
      {
        out Ref: Ref[VarDeclaration.ArrayDeclarationSymbol] = Reference.Ref.Resolve();
        Reference.Scope = Scope;
        Index.Scope = Scope;
        Value.Scope = Scope;

        Reference: Reference;
        Index: Expr;
        Value: Expr;
      }

    | Or : BoolExpr 
      { 
      }
    | And : BoolExpr 
      { 
      }
    | Equal : BoolExpr 
      { 
      }
    | NotEqual : BoolExpr 
      { 
      }
    | LessEqual : BoolExpr 
      { 
      }
    | Less : BoolExpr 
      { 
      }
    | GreaterEqual : BoolExpr 
      { 
      }
    | Greater : BoolExpr 
      { 
      }
    | Sum          : Binary { }
    | Sub          : Binary { }
    | Modulus      : Binary { }
    | Multiply     : Binary { }
    | Divide       : Binary { }

    | Plus          : Unary { }
    | Minus         : Unary { }
    | Negate        : Unary { }
    | LogicalNegate : Unary { }
  }

  abstract ast TypeReference 
  {
    in Type: TypeSymbol;

    | Void  { Type = context.GetVoidSymbol(); }
    | Int   { Type = context.GetIntSymbol(); }
    | Float { Type = context.GetFloatSymbol(); }
    | Bool  { Type = context.GetBoolSymbol(); }
  }

  declaration Root : Container {}

  declaration Void  : Type {}
  declaration Int   : Type {}
  declaration Float : Type {}
  declaration Bool  : Type {}
}