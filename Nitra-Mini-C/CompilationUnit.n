using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nitra;
using Nitra.Declarations;
using Nitra.ProjectSystem;
using System;
using System.Collections.Generic;
using System.Linq;
using DotNet;

namespace MiniC
{
  [Record]
  public class MiniCDependentPropertyEvalContext : DependentPropertyEvalContext
  {
    public Void  : VoidSymbol;
    public Int   : IntSymbol;
    public Float : FloatSymbol;
    public Bool  : BoolSymbol;
  }

  public module Evaluator
  {
    NoLocation : Location       = Location(SourceSnapshot.Default.File, NSpan(0));
    NoFile : ProjectSystem.File = SourceSnapshot.Default.File;
    NoSpan : NSpan              = NSpan(0);
    
    Init(project : Project) : void
    {
      def root = RootSymbol();
      def rootScope = TableScope("<root>", root);
      
      def defineSymbol[Type](name : string) : Type  where Type: DeclarationSymbol
      {
        def name = Name(NoFile, NoSpan, name);
        def symbol = ExternalDeclaration.[Type](name).DefineSymbol(rootScope);
        symbol
      }
      
      def voidSymbol  = defineSymbol.[VoidSymbol]("void");
      def intSymbol   = defineSymbol.[IntSymbol]("int");
      def floatSymbol = defineSymbol.[FloatSymbol]("float");
      def boolSymbol  = defineSymbol.[BoolSymbol]("bool");
      def context     = MiniCDependentPropertyEvalContext(voidSymbol, intSymbol, floatSymbol, boolSymbol);

      root.MemberTable = rootScope;
      root.Scope       = rootScope;
      root.FullName    = "<root>";
      root.Kind        = "root";
      root.AddDeclaration(ExternalDeclaration.[RootSymbol](Name(NoFile, NoSpan, "<root>")));

      voidSymbol.EvalProperties(context);
      intSymbol.EvalProperties(context); 
      floatSymbol.EvalProperties(context);
      boolSymbol.EvalProperties(context);
      root.EvalProperties(context);

      project.Data = (context, root);
    }

    static public RefreshProject(project : Project) : void
    {
      when (project.Data == null)
        Init(project);

      def (context, root) = project.Data :> MiniCDependentPropertyEvalContext * RootSymbol;
      
      root.MemberTable.Undefine(_.IsParsed);
      def evalHost = MiniCProjectEvalPropertiesHost(project, root);
      evalHost.EvalProperties(context, "Symbol hierarchy", 0);
      evalHost.EvalProperties(context, "Scopes", 1);
    }
  }
  
  public partial class CompilationUnit : AstBase, IProjectSupport
  {
    public RefreshProject(project: Project): void
    {
      Evaluator.RefreshProject(project);
    }
  }
  
  public class MiniCProjectEvalPropertiesHost : ProjectEvalPropertiesHost
  {
    _root : RootSymbol;

    public this(project : Project, root : RootSymbol)
    {
      base(project, [root]);
      _root = root;
    }

    protected override BeforeStage(context : DependentPropertyEvalContext, _passName : string) : void
    {
      match (context.Stage)
      {
        | 0 =>
          foreach (file in _files)
            when (file.Ast is CompilationUnit as cu)
              cu.ContainingTable = _root.MemberTable;

        | _ => ()
      }
    }
  }
}