using System.Threading;
using DotNet;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Extensions;

using Nitra;
using Nitra.Declarations;
using Nitra.ProjectSystem;

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;

namespace MiniC
{
  public variant VariableKind
  {
    | Global
    | Parameter
    | Local

    public static FromHeader(header: VarHeader): VariableKind
    {
      match (header)
      {
        | Global => Global()
        | Parameter => Parameter()
        | Local => Local()
        | _ => assert(false, $"Unexpected var header $header")
      }
    }
  }
  
  [Record]
  public class MiniCDependentPropertyEvalContext : DependentPropertyEvalContext
  {
    public Void       : VoidSymbol;
    public Int        : IntSymbol;
    public Float      : FloatSymbol;
    public Bool       : BoolSymbol;
  }

  public partial class CompilationUnit : AstBase, IProjectSupport
  {
    static NoLocation : Location       = Location(SourceSnapshot.Default.File, NSpan(0));
    static NoFile : ProjectSystem.File = SourceSnapshot.Default.File;
    static NoSpan : NSpan              = NSpan(0);
		
		public RefreshReferences(cancellationToken : CancellationToken, project : Project) : object
		{
		  _ = cancellationToken;
      def root = RootSymbol() <- 
      { 
        FullName = "<root>";
        Kind = "root";
      };
      
      root.MemberTable = TableScope("<root>", root);
      root.Scope = root.MemberTable;
      
      def defineSymbol[Type](name : string, putToRootScope: bool = true) : Type where Type: DeclarationSymbol
      {
        def name = Name(NoFile, NoSpan, name);
        def symbol = 
          if (putToRootScope)
            ExternalDeclaration.[Type](name).DefineSymbol(root.MemberTable)
          else
            ExternalDeclaration.[Type](name).DefineSymbol();
        symbol
      }
      
      def voidSymbol  = defineSymbol.[VoidSymbol]("void");
      def intSymbol   = defineSymbol.[IntSymbol]("int");
      def floatSymbol = defineSymbol.[FloatSymbol]("float");
      def boolSymbol  = defineSymbol.[BoolSymbol]("bool");
      def context = MiniCDependentPropertyEvalContext(voidSymbol, intSymbol, floatSymbol, boolSymbol);
      
      def definePrintSymbol(name : string, argType: TypeSymbol)
      {
        def symbol = defineSymbol.[FunDeclarationSymbol](name);
        symbol.ReturnType = voidSymbol;
        def printParam = defineSymbol.[VarDeclaration.ScalarDeclarationSymbol]("value", false);
        printParam.Type = argType;
        symbol.Parameters = array[printParam];
        printParam.EvalProperties(context);
        symbol.EvalProperties(context)
      }
      
      definePrintSymbol("iprint", intSymbol);
      definePrintSymbol("bprint", boolSymbol);
      definePrintSymbol("fprint", floatSymbol);
      
      root.AddDeclaration(ExternalDeclaration.[RootSymbol](Name(NoFile, NoSpan, "<root>")));

      voidSymbol.EvalProperties(context);
      intSymbol.EvalProperties(context); 
      floatSymbol.EvalProperties(context);
      boolSymbol.EvalProperties(context);
      root.EvalProperties(context);

      project.Data = (context, root);
      project.Data
		}

		public RefreshProject(cancellationToken : CancellationToken, compilerMessages : ICompilerMessages, files : ImmutableArray[FileEvalPropertiesData], data : object) : void
    {
      _ = compilerMessages;
      def (context, root) = data :> MiniCDependentPropertyEvalContext * RootSymbol;
      context.CancellationToken = cancellationToken;
      
      root.MemberTable.Undefine(_.IsParsed);
      def evalHost = MiniCProjectEvalPropertiesHost(files, root);
      evalHost.EvalProperties(context, "Symbol hierarchy", 0);
      evalHost.EvalProperties(context, "Scopes", 1);
    }
  }
  
  public class MiniCProjectEvalPropertiesHost : ProjectEvalPropertiesHost
  {
    _root : RootSymbol;

    public this(files : ImmutableArray[FileEvalPropertiesData], root : RootSymbol)
    {
      base(files, ImmutableArray.Create(root));
      _root = root;
    }

    protected override BeforeStage(context : DependentPropertyEvalContext, _passName : string) : void
    {
      match (context.Stage)
      {
        | 0 =>
          foreach (file in _files)
            when (file.Ast is CompilationUnit as cu)
              cu.ContainingTable = _root.MemberTable;

        | _ => ()
      }
    }
  }
}