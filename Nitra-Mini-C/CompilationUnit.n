using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nitra;
using Nitra.Declarations;
using Nitra.ProjectSystem;
using System;
using System.Collections.Generic;
using System.Linq;
using DotNet;

namespace MiniC
{
  public variant VariableKind
  {
    | Global
    | Parameter
    | Local
    public static FromHeader(header: VarHeader): VariableKind
    {
      match (header)
      {
        | Global => Global()
        | Parameter => Parameter()
        | Local => Local()
        | _ => assert(false, $"Unexpected var header $header")
      }
    }
  }
  
  [Record]
  public class MiniCDependentPropertyEvalContext : DependentPropertyEvalContext
  {
    public Void       : VoidSymbol;
    public Int        : IntSymbol;
    public Float      : FloatSymbol;
    public Bool       : BoolSymbol;
    public PrintInt   : FunDeclarationSymbol;
    public PrintBool  : FunDeclarationSymbol;
    public PrintFloat : FunDeclarationSymbol;
  }

  public module Evaluator
  {
    NoLocation : Location       = Location(SourceSnapshot.Default.File, NSpan(0));
    NoFile : ProjectSystem.File = SourceSnapshot.Default.File;
    NoSpan : NSpan              = NSpan(0);
    
    Init(project : Project) : void
    {
      def root = RootSymbol();
      def rootScope = TableScope("<root>", root);
      
      def defineSymbol[Type](name : string, putToRootScope: bool = true) : Type where Type: DeclarationSymbol
      {
        def name = Name(NoFile, NoSpan, name);
        def symbol = 
          if (putToRootScope)
            ExternalDeclaration.[Type](name).DefineSymbol(rootScope)
          else
            ExternalDeclaration.[Type](name).DefineSymbol();
        symbol
      }
      
      def voidSymbol  = defineSymbol.[VoidSymbol]("void");
      def intSymbol   = defineSymbol.[IntSymbol]("int");
      def floatSymbol = defineSymbol.[FloatSymbol]("float");
      def boolSymbol  = defineSymbol.[BoolSymbol]("bool");
      
      def definePrintSymbol(name : string, argType: TypeSymbol) : FunDeclarationSymbol
      {
        def symbol = defineSymbol.[FunDeclarationSymbol](name);
        symbol.ReturnType = voidSymbol;
        def printParam = defineSymbol.[VarDeclaration.ScalarDeclarationSymbol]("value", false);
        printParam.Type = argType;
        symbol.Parameters = array[printParam];
        symbol
      }
      
      def printIntSymbol = definePrintSymbol("iprint", intSymbol);
      def printBoolSymbol = definePrintSymbol("bprint", boolSymbol);
      def printFloatSymbol = definePrintSymbol("fprint", floatSymbol);
      def context = MiniCDependentPropertyEvalContext(voidSymbol, intSymbol, floatSymbol, boolSymbol, printIntSymbol, printBoolSymbol, printFloatSymbol);

      root.MemberTable = rootScope;
      root.Scope       = rootScope;
      root.FullName    = "<root>";
      root.Kind        = "root";
      root.AddDeclaration(ExternalDeclaration.[RootSymbol](Name(NoFile, NoSpan, "<root>")));

      voidSymbol.EvalProperties(context);
      intSymbol.EvalProperties(context); 
      floatSymbol.EvalProperties(context);
      boolSymbol.EvalProperties(context);
      printIntSymbol.EvalProperties(context);
      printBoolSymbol.EvalProperties(context);
      printFloatSymbol.EvalProperties(context);
      root.EvalProperties(context);

      project.Data = (context, root);
    }

    static public RefreshProject(project : Project) : void
    {
      when (project.Data == null)
        Init(project);

      def (context, root) = project.Data :> MiniCDependentPropertyEvalContext * RootSymbol;
      
      root.MemberTable.Undefine(_.IsParsed);
      def evalHost = MiniCProjectEvalPropertiesHost(project, root);
      evalHost.EvalProperties(context, "Symbol hierarchy", 0);
      evalHost.EvalProperties(context, "Scopes", 1);
    }
  }
  
  public partial class CompilationUnit : AstBase, IProjectSupport
  {
    public RefreshProject(project: Project): void
    {
      Evaluator.RefreshProject(project);
    }
  }
  
  public class MiniCProjectEvalPropertiesHost : ProjectEvalPropertiesHost
  {
    _root : RootSymbol;

    public this(project : Project, root : RootSymbol)
    {
      base(project, [root]);
      _root = root;
    }

    protected override BeforeStage(context : DependentPropertyEvalContext, _passName : string) : void
    {
      match (context.Stage)
      {
        | 0 =>
          foreach (file in _files)
            when (file.Ast is CompilationUnit as cu)
              cu.ContainingTable = _root.MemberTable;

        | _ => ()
      }
    }
  }
}