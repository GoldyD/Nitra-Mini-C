using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Extensions;

using Nitra.Declarations;
using Nitra.ProjectSystem;

using System;
using System.Console;
using System.Collections.Generic;
using System.Linq;
using Microsoft.Cci;
using Microsoft.Cci.MutableCodeModel;

namespace MiniC.Compiler
{
  class DotNetBackend: IDisposable
  {
    _file: File;
    _nameTable: NameTable = NameTable();
    _host: PeReader.DefaultHost = PeReader.DefaultHost(_nameTable);
    _rootUnitNamespace: RootUnitNamespace;
    _assembly: Assembly;
    _mainClass: NamespaceTypeDefinition;
    
    public static GenerateAssembly(file: File, output: string): void
    {
      using (backend = DotNetBackend(file, output))
      {
        def visitor = AstVisitor();
        file.Ast.Accept(visitor);
      }
    }
    
    public this(file: File, outputPath: string)
    {
      _file = file;
      def coreAssembly = _host.LoadAssembly(_host.CoreAssemblySymbolicIdentity);

      _assembly = Assembly() <- 
      {
        Name = _nameTable.GetNameFor("hello");
        ModuleName = _nameTable.GetNameFor("hello.exe");
        PlatformType = _host.PlatformType;
        Kind = ModuleKind.ConsoleApplication;
        RequiresStartupStub = _host.PointerSize == 4;
        TargetRuntimeVersion = coreAssembly.TargetRuntimeVersion
      };
        
      _assembly.AssemblyReferences.Add(coreAssembly);
      _rootUnitNamespace = RootUnitNamespace() <- { Unit = _assembly };
      _assembly.UnitNamespaceRoot = _rootUnitNamespace;
     
      def moduleClass = NamespaceTypeDefinition() <-
      {
        ContainingUnitNamespace = _rootUnitNamespace;
        InternFactory = _host.InternFactory;
        IsClass = true;
        Name = _nameTable.GetNameFor("<Module>")
      };
      _assembly.AllTypes.Add(moduleClass);

      _mainClass = NamespaceTypeDefinition() <-
      {
        ContainingUnitNamespace = _rootUnitNamespace;
        InternFactory = _host.InternFactory;
        IsClass = true;
        IsPublic = true;
        Methods = List();
        Name = _nameTable.GetNameFor("Main");
        BaseClasses = List([_host.PlatformType.SystemObject]);  
      };
      _rootUnitNamespace.Members.Add(_mainClass);
      _assembly.AllTypes.Add(_mainClass);
      
      def outputPath = 
        if (string.IsNullOrWhiteSpace(outputPath)) 
          IO.Path.GetDirectoryName(_file.FullName) 
        else 
          outputPath;
            
      def outputFileName = IO.Path.Combine(outputPath, IO.Path.ChangeExtension(IO.Path.GetFileNameWithoutExtension(_file.FullName), ".exe"));
        
      using (peStream = IO.File.Create(outputFileName))
        PeWriter.WritePeToStream(_assembly, _host, peStream);
    }
    
    //def ilGenerator = ILGenerator(_host, mainMethod);

    //  def systemConsole = UnitHelper.FindType(_nameTable, coreAssembly, "System.Console");
    //  def writeLine = TypeHelper.GetMethod(systemConsole, _nameTable.GetNameFor("WriteLine"), _host.PlatformType.SystemString);

    //  ilGenerator.Emit(OperationCode.Ldstr, "hello");
    //  ilGenerator.Emit(OperationCode.Call, writeLine);
    //  ilGenerator.Emit(OperationCode.Ret);

    //  def body = ILGeneratorMethodBody(ilGenerator, true, 1, mainMethod, [], []);

    public Method(name: string, body: ILGeneratorMethodBody): MethodDefinition
    {
      def name = if (name == "main") "Main" else name;
      def method = MethodDefinition() <-
      {
        ContainingTypeDefinition = _mainClass;
        InternFactory = _host.InternFactory;
        IsCil = true;
        IsStatic = true;
        Name = _nameTable.GetNameFor(name);
        Type = _host.PlatformType.SystemVoid;
        Visibility = TypeMemberVisibility.Public
      };
      
      when (name == "Main") _assembly.EntryPoint = method;
      _mainClass.Methods.Add(method);
      method
    }
    
    public Dispose(): void 
    { 
      _host.Dispose()
    }
  }
}