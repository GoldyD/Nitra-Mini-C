using Microsoft.Cci;
using Microsoft.Cci.MutableCodeModel;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Extensions;

using Nitra.Declarations;
using Nitra.ProjectSystem;

using System;
using System.Console;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace MiniC.Compiler
{
  type Op = OperationCode;
  
  class FuncBodyAstVisitor : IAstVisitor
  {
    public Visit(ast: IAst) : void
    {
      WriteLine(ast);
      
      match (ast)
      {
        | decls is TopDeclaration.AstList => decls.Accept(this);
        | _ => WriteLine($"Unhandled! $ast");
      }
      
      ast.Accept(this);
    }
    
    public Visit(r: IRef): void
    {
      _ = r;
    }
    
    public Visit(name: Name): void implements IAstVisitor.Visit
    {
      _ = name;
    }
    
    public Visit(reference: Reference): void implements IAstVisitor.Visit
    {
      _ = reference;
    }
    
  }
  
  [Record]
  class MethodContext
  {
    _backend           : DotNetBackend;
    _nameTable         : NameTable;
    public Method      : MethodDefinition;
    public IlGenerator : ILGenerator;
    [RecordIgnore]
    _parameterMap      : Dictionary[VarDeclarationSymbol, IParameterDefinition] = Dictionary();
    [RecordIgnore]
    _localVars         : List[LocalDefinition] = List();
    [RecordIgnore]
    _localVarMap       : Dictionary[VarDeclarationSymbol, ILocalDefinition] = Dictionary();
    [RecordIgnore]
    _argMap            : Dictionary[VarDeclarationSymbol, ILocalDefinition] = Dictionary();
    [RecordIgnore]
    _whileExitLabelMap : Dictionary[Statement.While, ILGeneratorLabel] = Dictionary();
    
    public LocalVars : Seq[LocalDefinition] { get { _localVars } }
    
    public GetCciLocalVar(varDeclSymbol : VarDeclarationSymbol) : ILocalDefinition
    {
      _localVarMap[varDeclSymbol]
    }
    
    public AddLocalVar(varDeclSymbol : VarDeclarationSymbol) : void
    {
      def cciLocalVar = LocalDefinition() <-
      {
        MethodDefinition = Method;
        Name = _nameTable.GetNameFor(varDeclSymbol.Name);
        Type = _backend.GetVariableType(varDeclSymbol);
      };
      
      IlGenerator.AddVariableToCurrentScope(cciLocalVar);
      _localVars.Add(cciLocalVar);
      _localVarMap.Add(varDeclSymbol, cciLocalVar);
    }
    
    public AddParameter(paramSymbol : VarDeclarationSymbol) : void
    {
      def cciParameter = ParameterDefinition();
      cciParameter.Name = _nameTable.GetNameFor(paramSymbol.Name);
      cciParameter.Type = _backend.GetVariableType(paramSymbol);
      Method.Parameters.Add(cciParameter);
      _parameterMap[paramSymbol] = cciParameter;
    }
    
    public GetCciParameter(paramSymbol : VarDeclarationSymbol) : IParameterDefinition
    {
      _parameterMap[paramSymbol]
    }
    
    public GetOrNewWhileExitLabel(w: Statement.While): ILGeneratorLabel
    {
      mutable label;
      unless (_whileExitLabelMap.TryGetValue(w, out label))
      {
        label = ILGeneratorLabel();
        _whileExitLabelMap[w] = label;
      }
      label
    }
    
    public TryFindWhileExitLabel(w: Statement.While): option[ILGeneratorLabel]
    {
      mutable label;
      if (_whileExitLabelMap.TryGetValue(w, out label)) Some(label) else None()
    }
  }
  
  class DotNetBackend : IDisposable
  {
    _project           : Project;
    _context           : MiniCDependentPropertyEvalContext;
    _nameTable         : NameTable = NameTable();
    _host              : PeReader.DefaultHost = PeReader.DefaultHost(_nameTable);
    _rootUnitNamespace : RootUnitNamespace;
    _assembly          : Assembly;
    _mainClass         : NamespaceTypeDefinition;
    _coreAssembly      : IAssembly;
    _globalVarMap      : Dictionary[VarDeclarationSymbol, IFieldDefinition] = Dictionary();
    _functionMap       : Dictionary[FunDeclarationSymbol, IMethodDefinition] = Dictionary();
    
    public static GenerateAssembly(project : Project, outputPath: string): void
    {
      def (context, rootSymbol) = project.Data :> MiniCDependentPropertyEvalContext * RootSymbol;
          
      using (backend = DotNetBackend(project))
      {
        foreach (symbols in rootSymbol.MemberTable.Symbols)
          foreach (toDeclSymbol in symbols)
          {
            | funcDecl is FunDeclarationSymbol => backend.Add(funcDecl)
            | varDecl  is VarDeclarationSymbol => backend.Add(varDecl)
            | s when ReferenceEquals(s, context.Void)
                  || ReferenceEquals(s, context.Bool)
                  || ReferenceEquals(s, context.Int)
                  || ReferenceEquals(s, context.Float) => ()
            | _ => assert(false);
          }
        backend.GenerateAssembly(outputPath);
      }
    }
    
    public this(project : Project)
    {
      _project = project;
      (_context, _) = project.Data :> MiniCDependentPropertyEvalContext * RootSymbol;
      _coreAssembly = _host.LoadAssembly(_host.CoreAssemblySymbolicIdentity);
      
      _assembly = Assembly() <- 
      {
        Name = _nameTable.GetNameFor("hello");
        ModuleName = _nameTable.GetNameFor("hello.exe");
        PlatformType = _host.PlatformType;
        Kind = ModuleKind.ConsoleApplication;
        RequiresStartupStub = _host.PointerSize == 4;
        TargetRuntimeVersion = _coreAssembly.TargetRuntimeVersion
      };
        
      _assembly.AssemblyReferences.Add(_coreAssembly);
      _rootUnitNamespace = RootUnitNamespace() <- { Unit = _assembly };
      _assembly.UnitNamespaceRoot = _rootUnitNamespace;
     
      def moduleClass = NamespaceTypeDefinition() <-
      {
        ContainingUnitNamespace = _rootUnitNamespace;
        InternFactory = _host.InternFactory;
        IsClass = true;
        Name = _nameTable.GetNameFor("<Module>")
      };
      _assembly.AllTypes.Add(moduleClass);

      _mainClass = NamespaceTypeDefinition() <-
      {
        ContainingUnitNamespace = _rootUnitNamespace;
        InternFactory = _host.InternFactory;
        IsClass = true;
        IsPublic = true;
        IsStatic = true;
        Fields = List();
        Methods = List();
        Name = _nameTable.GetNameFor("Main");
        BaseClasses = List([_host.PlatformType.SystemObject]);  
      };
      _rootUnitNamespace.Members.Add(_mainClass);
      _assembly.AllTypes.Add(_mainClass);
    }
     
    GenerateAssembly(outputPath: string): void
    {
      def outputPath = 
        if (string.IsNullOrWhiteSpace(outputPath))
          if (_project.Files.IsEmpty())
            Path.Combine(_project.ProjectDir, "out.exe")
          else 
            Path.ChangeExtension(_project.Files.First().FullName, ".exe")
        else 
          outputPath;
            
      using (peStream = IO.File.Create(outputPath))
        PeWriter.WritePeToStream(_assembly, _host, peStream);
    }
    
    public Add(var : VarDeclarationSymbol): void
    {
      def field = FieldDefinition() <- {
        ContainingTypeDefinition = _mainClass;
        Name = _nameTable.GetNameFor(var.Name);
        Type = GetVariableType(var);
        IsStatic = true;
        Visibility = TypeMemberVisibility.Public;
        IsReadOnly = false;
      };
      
      _mainClass.Fields.Add(field);
      _globalVarMap[var] = field
    }    
    
    public Add(func : FunDeclarationSymbol): void
    {
      if (func.HasParsedDeclarations)
      {
        def name = func.Name;
        def method = MethodDefinition() <-
        {
          ContainingTypeDefinition = _mainClass;
          InternFactory = _host.InternFactory;
          IsCil = true;
          IsStatic = true;
          Name = _nameTable.GetNameFor(name);
          Type = GetType(func.ReturnType);
          Parameters = List();
          Visibility = TypeMemberVisibility.Public
        };
     
        method.Body = GenerateBody(func, method);
      
        when (name.Equals("main", StringComparison.InvariantCultureIgnoreCase))
          _assembly.EntryPoint = method;
        _mainClass.Methods.Add(method);
        _functionMap[func] = method;
      }
      else
      {
        def writeLineFun(returnType)
        {
          def systemConsole = UnitHelper.FindType(_nameTable, _coreAssembly, "System.Console");
          TypeHelper.GetMethod(systemConsole, _nameTable.GetNameFor("WriteLine"), returnType);
        }
      
        _functionMap[_context.PrintInt] = writeLineFun(_host.PlatformType.SystemInt32);
        _functionMap[_context.PrintBool] = writeLineFun(_host.PlatformType.SystemBoolean);
      }
    }
    
    GenerateBody(func : FunDeclarationSymbol, method : MethodDefinition) : IMethodBody
    {
      def compoundStatement = func.Declarations.First().Body;
      def methodContext = MethodContext(this, _nameTable, method, ILGenerator(_host, method));
      func.Parameters.Iter(methodContext.AddParameter);
      GenerateCompoundStatement(methodContext, compoundStatement);
      ILGeneratorMethodBody(methodContext.IlGenerator, true, 10, method, methodContext.LocalVars, []);
    }
    
    GenerateCompoundStatement(methodContext : MethodContext, compoundStatement: CompoundStatement) : void
    {
      def gen = methodContext.IlGenerator;
      gen.BeginScope();
      
      foreach (var in compoundStatement.LocalVariables)
        methodContext.AddLocalVar(var.Symbol);
      
      foreach (statement in compoundStatement.Statements)
        GenerateStatement(methodContext, statement);
        
      gen.EndScope();
    }
    
    GenerateStatement(methodContext : MethodContext, statement : Statement): void 
    {
      def gen = methodContext.IlGenerator;
      
      match (statement)
      {
        | Expression as s => GenerateExpression(methodContext, s.Body);
        | ReturnVoid => gen.Emit(Op.Ret);
        
        | Return as s =>
            GenerateExpression(methodContext, s.Value);
            gen.Emit(Op.Ret);
            
        | Compound as s =>
            GenerateCompoundStatement(methodContext, s.Nested);
        
        | If as s =>
            def exitLabel = ILGeneratorLabel();
            GenerateExpression(methodContext, s.Condition);
            gen.Emit(Op.Brfalse, exitLabel);
            // if true
            GenerateStatement(methodContext, s.Body);
            gen.Emit(Op.Br, exitLabel);
            gen.MarkLabel(exitLabel);
        
        | IfElse as s =>
            def falseBranchLabel = ILGeneratorLabel();
            def exitLabel = ILGeneratorLabel();
            GenerateExpression(methodContext, s.Condition);
            gen.Emit(Op.Brfalse, falseBranchLabel);
            // true branch
            GenerateStatement(methodContext, s.TrueBranch);
            gen.Emit(Op.Br, exitLabel);
            // false branch
            gen.MarkLabel(falseBranchLabel);
            GenerateStatement(methodContext, s.FalseBranch);
            gen.MarkLabel(exitLabel);
            
        | While as w =>
            def bodyLabel = ILGeneratorLabel();
            def conditionLabel = ILGeneratorLabel();
            gen.Emit(Op.Br, conditionLabel);
            gen.MarkLabel(bodyLabel);
            GenerateStatement(methodContext, w.Body);
            gen.MarkLabel(conditionLabel);
            GenerateExpression(methodContext, w.Condition);
            gen.Emit(Op.Brtrue, bodyLabel);
            
            match (methodContext.TryFindWhileExitLabel(w))
            {
              | Some(label) => gen.MarkLabel(label)
              | None => ()
            }
            
        | Break (Loop = Some(loop)) =>
            def whileExitLabel = methodContext.GetOrNewWhileExitLabel(loop);
            gen.Emit(Op.Br, whileExitLabel);
            
        | _ => WriteLine($"Unhandlend statement! $statement");
      }
    }
    
    GenerateExpression(methodContext : MethodContext, expr : Expr) : void
    {
      def gen = methodContext.IlGenerator;

      match (expr)
      {
        | IntegerLiteral as e => gen.Emit(Op.Ldc_I4, e.Value.Value)
        | TrueLiteral => gen.Emit(Op.Ldc_I4_1)
        | FalseLiteral => gen.Emit(Op.Ldc_I4_0)
        | VariableRef as e => LoadVar(gen, methodContext, e.Ref.Symbol)
        | ScalarAssignment as assignment =>
            GenerateExpression(methodContext, assignment.Value);
            def cciVar = methodContext.GetCciLocalVar(assignment.Ref.Symbol);
            gen.Emit(Op.Stloc, cciVar);
          
        | FunCall as call =>
            foreach (arg in call.Arguments)
              GenerateExpression(methodContext, arg);

            gen.Emit(Op.Call, _functionMap[call.Ref.Symbol])
        
        | Argument as arg => GenerateExpression(methodContext, arg.Expr)
        | Binary as bin =>
            GenerateExpression(methodContext, bin.Expr1);
            GenerateExpression(methodContext, bin.Expr2);
            def opCode =
              match (bin) 
              {
                | Or => Op.Or
                | And => Op.And
                | Equal => Op.Ceq
                | NotEqual =>
                    gen.Emit(Op.Ceq);
                    gen.Emit(Op.Ldc_I4_0);
                    Op.Ceq;
                | LessEqual => 
                    gen.Emit(Op.Cgt);
                    gen.Emit(Op.Ldc_I4_0);
                    Op.Ceq
                | Less => Op.Clt
                | GreaterEqual =>
                    gen.Emit(Op.Clt);
                    gen.Emit(Op.Ldc_I4_0);
                    Op.Ceq
                | Greater => Op.Cgt
                | Sum => Op.Add
                | Sub => Op.Sub
                | Modulus => Op.Rem
                | Multiply => Op.Mul
                | Divide => Op.Div
                | _ => assert(false, $"Unhandled binary expression $bin")
              }
            gen.Emit(opCode);
        | Unary as unary =>
            GenerateExpression(methodContext, unary.Expr1);
            match (unary) 
            {
              | Plus => ()
              | Minus => gen.Emit(Op.Neg)
              | Negate =>
                  gen.Emit(Op.Ldc_I4_0);
                  gen.Emit(Op.Ceq)
              | _ => assert(false, $"Unhandled unary expression $unary")
            }
            
        | ArraySize as e =>
            LoadVar(gen, methodContext, e.Ref.Symbol);
            gen.Emit(Op.Ldlen);
            
        | ArrayAllocation as a =>
            GenerateExpression(methodContext, a.Size);
            gen.Emit(Op.Newarr, GetArrayType(a.Type));
            
        | _ => WriteLine($"Unhandled expression! $expr")
      }
      
      when (!expr.Used && !MiniCTypeUnifier.Instance.TryUnify(expr.Type, _context.Void))
        gen.Emit(Op.Pop);
    }
    
    LoadVar(ilGenerator: ILGenerator, context: MethodContext, symbol: VarDeclarationSymbol): void
    {
      match (symbol.VarKind)
      {
        | Global =>
          {
            def cciVar = _globalVarMap[symbol];
            ilGenerator.Emit(Op.Ldsfld, cciVar)
          }
        | Local =>
          {
            def cciVar = context.GetCciLocalVar(symbol);
            ilGenerator.Emit(Op.Ldloc, cciVar)
          }
        | Parameter =>
          {
            def cciParam = context.GetCciParameter(symbol);
            ilGenerator.Emit(Op.Ldarg, cciParam)
          }
        | _ => assert(false, $"Unhandled $(symbol.VarKind)")
      }
    }
    
    public GetType(typeSymbol: TypeSymbol): ITypeReference
    {
      match (typeSymbol)
      {
        | IntSymbol   => _host.PlatformType.SystemInt32
        | FloatSymbol => _host.PlatformType.SystemFloat64
        | BoolSymbol  => _host.PlatformType.SystemBoolean
        | VoidSymbol  => _host.PlatformType.SystemVoid
        | _           => assert(false, $"Unhandled $typeSymbol")
      }
    }
    
    GetArrayType(typeSymbol: TypeSymbol): IArrayTypeReference
    {
      def elementType = GetType(typeSymbol);
      VectorTypeReference() <-
      {
        TypeCode = PrimitiveTypeCode.NotPrimitive;
        PlatformType = _host.PlatformType;
        ElementType = elementType;
        InternFactory = _host.InternFactory;
      }
    }
    
    public GetVariableType(var: VarDeclarationSymbol): ITypeReference
    {
      match (var)
      {
        | VarDeclaration.ScalarDeclarationSymbol => GetType(var.Type)
        | VarDeclaration.ArrayDeclarationSymbol => GetArrayType(var.Type)
      }
    }
    
    public Dispose(): void 
    { 
      _host.Dispose()
    }
  }
}