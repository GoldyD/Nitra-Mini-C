using Microsoft.Cci;
using Microsoft.Cci.MutableCodeModel;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Extensions;

using Nitra.Declarations;
using Nitra.ProjectSystem;

using System;
using System.Console;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace MiniC.Compiler
{
  class FuncBodyAstVisitor : IAstVisitor
  {
    public Visit(ast: IAst) : void
    {
      WriteLine(ast);
      
      match (ast)
      {
        | decls is TopDeclaration.AstList => decls.Accept(this);
        | _ => WriteLine($"Unhandled! $ast");
      }
      
      ast.Accept(this);
    }
    
    public Visit(r: IRef): void
    {
      _ = r;
    }
    
    public Visit(name: Name): void implements IAstVisitor.Visit
    {
      _ = name;
    }
    
    public Visit(reference: Reference): void implements IAstVisitor.Visit
    {
      _ = reference;
    }
    
  }
  
  class DotNetBackend : IDisposable
  {
    _project : Project;
    _nameTable: NameTable = NameTable();
    _host: PeReader.DefaultHost = PeReader.DefaultHost(_nameTable);
    _rootUnitNamespace: RootUnitNamespace;
    _assembly: Assembly;
    _mainClass: NamespaceTypeDefinition;
    _coreAssembly: IAssembly;
    
    public static GenerateAssembly(project : Project, outputPath: string): void
    {
      def (context, rootSymbol) = project.Data :> MiniCDependentPropertyEvalContext * RootSymbol;
          
      using (backend = DotNetBackend(project))
      {
        foreach (symbols in rootSymbol.MemberTable.Symbols)
          foreach (toDeclSymbol in symbols)
          {
            | funcDecl is FunDeclarationSymbol => backend.Add(funcDecl)
            | varDecl  is VarDeclarationSymbol => backend.Add(varDecl)
            | s when ReferenceEquals(s, context.Void)
                  || ReferenceEquals(s, context.Bool)
                  || ReferenceEquals(s, context.Int)
                  || ReferenceEquals(s, context.Float) => ()
            | _ => assert(false);
          }
        backend.GenerateAssembly(outputPath);
      }
    }
    
    public this(project : Project)
    {
      _project = project;
      _coreAssembly = _host.LoadAssembly(_host.CoreAssemblySymbolicIdentity);

      _assembly = Assembly() <- 
      {
        Name = _nameTable.GetNameFor("hello");
        ModuleName = _nameTable.GetNameFor("hello.exe");
        PlatformType = _host.PlatformType;
        Kind = ModuleKind.ConsoleApplication;
        RequiresStartupStub = _host.PointerSize == 4;
        TargetRuntimeVersion = _coreAssembly.TargetRuntimeVersion
      };
        
      _assembly.AssemblyReferences.Add(_coreAssembly);
      _rootUnitNamespace = RootUnitNamespace() <- { Unit = _assembly };
      _assembly.UnitNamespaceRoot = _rootUnitNamespace;
     
      def moduleClass = NamespaceTypeDefinition() <-
      {
        ContainingUnitNamespace = _rootUnitNamespace;
        InternFactory = _host.InternFactory;
        IsClass = true;
        Name = _nameTable.GetNameFor("<Module>")
      };
      _assembly.AllTypes.Add(moduleClass);

      _mainClass = NamespaceTypeDefinition() <-
      {
        ContainingUnitNamespace = _rootUnitNamespace;
        InternFactory = _host.InternFactory;
        IsClass = true;
        IsPublic = true;
        IsStatic = true;
        Fields = List();
        Methods = List();
        Name = _nameTable.GetNameFor("Main");
        BaseClasses = List([_host.PlatformType.SystemObject]);  
      };
      _rootUnitNamespace.Members.Add(_mainClass);
      _assembly.AllTypes.Add(_mainClass);
    }
     
    GenerateAssembly(outputPath: string): void
    {
      def outputPath = 
        if (string.IsNullOrWhiteSpace(outputPath))
          if (_project.Files.IsEmpty())
            Path.Combine(_project.ProjectDir, "out.exe")
          else 
            Path.ChangeExtension(_project.Files.First().FullName, ".exe")
        else 
          outputPath;
            
      using (peStream = IO.File.Create(outputPath))
        PeWriter.WritePeToStream(_assembly, _host, peStream);
    }
    
    
    public Add(var : VarDeclarationSymbol): void
    {
      def field = FieldDefinition() <- {
        ContainingTypeDefinition = _mainClass;
        Name = _nameTable.GetNameFor(var.Name);
        Type = GetType(var.Type);
        IsStatic = true;
        Visibility = TypeMemberVisibility.Public;
        IsReadOnly = false;
      };
      _mainClass.Fields.Add(field);
    }    
    
    public Add(func : FunDeclarationSymbol): void
    {
      def name = func.Name;
      //method.Body = GenerateCompoundStatement(method, fn.Body);
      def method = MethodDefinition() <-
      {
        ContainingTypeDefinition = _mainClass;
        InternFactory = _host.InternFactory;
        IsCil = true;
        IsStatic = true;
        Name = _nameTable.GetNameFor(name);
        Type = GetType(func.ReturnType);
        Parameters = List();
        Visibility = TypeMemberVisibility.Public
      };
      
      foreach (p in func.Parameters)
      {
        def cciParametr = ParameterDefinition();
        cciParametr.Name = _nameTable.GetNameFor(p.Name);
        cciParametr.Type = GetType(p.Type);
        method.Parameters.Add(cciParametr);
      }
      
      method.Body = MakeBody(func, method);
      
      when (name.Equals("main", StringComparison.InvariantCultureIgnoreCase))
        _assembly.EntryPoint = method;
      _mainClass.Methods.Add(method);
    }
    
    MakeBody(func : FunDeclarationSymbol, method : MethodDefinition) : IMethodBody
    {
      def compoundStatement = func.Declarations.First().Body;
      GenerateCompoundStatement(method, compoundStatement)
    }
    
    GetType(typeSymbol: TypeSymbol): ITypeReference
    {
      match (typeSymbol)
      {
        | _ is IntSymbol => _host.PlatformType.SystemInt32;
        | _ is FloatSymbol => _host.PlatformType.SystemFloat64;
        | _ is BoolSymbol => _host.PlatformType.SystemBoolean;
        | _ is VoidSymbol => _host.PlatformType.SystemVoid;
        | _ => assert(false)
      }
    }
    
    GenerateCompoundStatement(method: MethodDefinition, compoundStatement: CompoundStatement): ILGeneratorMethodBody
    {
      def ilGenerator = ILGenerator(_host, method);
      def nameTable = NameTable();
      
      def localVars = compoundStatement.LocalVariables.Map(var =>
          LocalDefinition() <-
          {
            MethodDefinition = method;
            Name = nameTable.GetNameFor(var.Name.Text);
            Type = GetType(var.Symbol.Type);
          });
      
      foreach (localVar in localVars)
        ilGenerator.AddVariableToCurrentScope(localVar);
      
      foreach (statement in compoundStatement.Statements)
        GenerateStatement(ilGenerator, statement);
      
      ILGeneratorMethodBody(ilGenerator, true, 10, method, localVars, []);
    }
    
    GenerateStatement(ilGenerator: ILGenerator, statement: Statement): void 
    {
      match (statement) {
      | expr is Statement.Expression => GenerateExpression(ilGenerator, expr.Body);
      | Statement.ReturnVoid => ilGenerator.Emit(OperationCode.Ret);
      | _ => WriteLine($"Unhandlend statement! $statement");
      }
    }
    
    GenerateExpression(ilGenerator: ILGenerator, expr: Expr): void
    {
      match (expr) {
      | assignment is Expr.ScalarAssignment => ()
        //ilGenerator.Emit(OperationCode.Ldloc, );
      | _ => WriteLine($"Unhandled expression! $expr");
      }
    }
    
    public Dispose(): void 
    { 
      _host.Dispose()
    }
  }
}