using Microsoft.Cci;
using Microsoft.Cci.MutableCodeModel;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Extensions;

using Nitra.Declarations;
using Nitra.ProjectSystem;

using System;
using System.Console;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace MiniC.Compiler
{
  class FuncBodyAstVisitor : IAstVisitor
  {
    public Visit(ast: IAst) : void
    {
      WriteLine(ast);
      
      match (ast)
      {
        | decls is TopDeclaration.AstList => decls.Accept(this);
        | _ => WriteLine($"Unhandled! $ast");
      }
      
      ast.Accept(this);
    }
    
    public Visit(r: IRef): void
    {
      _ = r;
    }
    
    public Visit(name: Name): void implements IAstVisitor.Visit
    {
      _ = name;
    }
    
    public Visit(reference: Reference): void implements IAstVisitor.Visit
    {
      _ = reference;
    }
    
  }
  
  [Record]
  class MethodContext
  {
    _backend           : DotNetBackend;
    _nameTable         : NameTable;
    public Method      : MethodDefinition;
    public IlGenerator : ILGenerator;
    [RecordIgnore]
    _localVars   : List[LocalDefinition] = List();
    [RecordIgnore]
    _localVarMap   : Dictionary[VarDeclarationSymbol, ILocalDefinition] = Dictionary();
    
    public LocalVars : Seq[LocalDefinition] { get { _localVars } }
    
    public GetCciLocalVar(varDeclSymbol : VarDeclarationSymbol) : ILocalDefinition
    {
      _localVarMap[varDeclSymbol]
    }
    
    public AddLocalVar(varDeclSymbol : VarDeclarationSymbol) : void
    {
      def cciLocalVar = LocalDefinition() <-
      {
        MethodDefinition = Method;
        Name = _nameTable.GetNameFor(varDeclSymbol.Name);
        Type = _backend.GetType(varDeclSymbol.Type);
      };
      IlGenerator.AddVariableToCurrentScope(cciLocalVar);
      _localVars.Add(cciLocalVar);
      _localVarMap.Add(varDeclSymbol, cciLocalVar);
    }
  }
  
  class DotNetBackend : IDisposable
  {
    _project           : Project;
    _nameTable         : NameTable = NameTable();
    _host              : PeReader.DefaultHost = PeReader.DefaultHost(_nameTable);
    _rootUnitNamespace : RootUnitNamespace;
    _assembly          : Assembly;
    _mainClass         : NamespaceTypeDefinition;
    _coreAssembly      : IAssembly;
    
    public static GenerateAssembly(project : Project, outputPath: string): void
    {
      def (context, rootSymbol) = project.Data :> MiniCDependentPropertyEvalContext * RootSymbol;
          
      using (backend = DotNetBackend(project))
      {
        foreach (symbols in rootSymbol.MemberTable.Symbols)
          foreach (toDeclSymbol in symbols)
          {
            | funcDecl is FunDeclarationSymbol => backend.Add(funcDecl)
            | varDecl  is VarDeclarationSymbol => backend.Add(varDecl)
            | s when ReferenceEquals(s, context.Void)
                  || ReferenceEquals(s, context.Bool)
                  || ReferenceEquals(s, context.Int)
                  || ReferenceEquals(s, context.Float) => ()
            | _ => assert(false);
          }
        backend.GenerateAssembly(outputPath);
      }
    }
    
    public this(project : Project)
    {
      _project = project;
      _coreAssembly = _host.LoadAssembly(_host.CoreAssemblySymbolicIdentity);

      _assembly = Assembly() <- 
      {
        Name = _nameTable.GetNameFor("hello");
        ModuleName = _nameTable.GetNameFor("hello.exe");
        PlatformType = _host.PlatformType;
        Kind = ModuleKind.ConsoleApplication;
        RequiresStartupStub = _host.PointerSize == 4;
        TargetRuntimeVersion = _coreAssembly.TargetRuntimeVersion
      };
        
      _assembly.AssemblyReferences.Add(_coreAssembly);
      _rootUnitNamespace = RootUnitNamespace() <- { Unit = _assembly };
      _assembly.UnitNamespaceRoot = _rootUnitNamespace;
     
      def moduleClass = NamespaceTypeDefinition() <-
      {
        ContainingUnitNamespace = _rootUnitNamespace;
        InternFactory = _host.InternFactory;
        IsClass = true;
        Name = _nameTable.GetNameFor("<Module>")
      };
      _assembly.AllTypes.Add(moduleClass);

      _mainClass = NamespaceTypeDefinition() <-
      {
        ContainingUnitNamespace = _rootUnitNamespace;
        InternFactory = _host.InternFactory;
        IsClass = true;
        IsPublic = true;
        IsStatic = true;
        Fields = List();
        Methods = List();
        Name = _nameTable.GetNameFor("Main");
        BaseClasses = List([_host.PlatformType.SystemObject]);  
      };
      _rootUnitNamespace.Members.Add(_mainClass);
      _assembly.AllTypes.Add(_mainClass);
    }
     
    GenerateAssembly(outputPath: string): void
    {
      def outputPath = 
        if (string.IsNullOrWhiteSpace(outputPath))
          if (_project.Files.IsEmpty())
            Path.Combine(_project.ProjectDir, "out.exe")
          else 
            Path.ChangeExtension(_project.Files.First().FullName, ".exe")
        else 
          outputPath;
            
      using (peStream = IO.File.Create(outputPath))
        PeWriter.WritePeToStream(_assembly, _host, peStream);
    }
    
    
    public Add(var : VarDeclarationSymbol): void
    {
      def field = FieldDefinition() <- {
        ContainingTypeDefinition = _mainClass;
        Name = _nameTable.GetNameFor(var.Name);
        Type = GetType(var.Type);
        IsStatic = true;
        Visibility = TypeMemberVisibility.Public;
        IsReadOnly = false;
      };
      _mainClass.Fields.Add(field);
    }    
    
    public Add(func : FunDeclarationSymbol): void
    {
      def name = func.Name;
      //method.Body = GenerateCompoundStatement(method, fn.Body);
      def method = MethodDefinition() <-
      {
        ContainingTypeDefinition = _mainClass;
        InternFactory = _host.InternFactory;
        IsCil = true;
        IsStatic = true;
        Name = _nameTable.GetNameFor(name);
        Type = GetType(func.ReturnType);
        Parameters = List();
        Visibility = TypeMemberVisibility.Public
      };
      
      foreach (p in func.Parameters)
      {
        def cciParametr = ParameterDefinition();
        cciParametr.Name = _nameTable.GetNameFor(p.Name);
        cciParametr.Type = GetType(p.Type);
        method.Parameters.Add(cciParametr);
      }
      
      method.Body = MakeBody(func, method);
      
      when (name.Equals("main", StringComparison.InvariantCultureIgnoreCase))
        _assembly.EntryPoint = method;
      _mainClass.Methods.Add(method);
    }
    
    MakeBody(func : FunDeclarationSymbol, method : MethodDefinition) : IMethodBody
    {
      def compoundStatement = func.Declarations.First().Body;
      def methodContext     = MethodContext(this, _nameTable, method, ILGenerator(_host, method));
      GenerateCompoundStatement(methodContext, compoundStatement);
      ILGeneratorMethodBody(methodContext.IlGenerator, true, 10, method, methodContext.LocalVars, []);
    }
    
    GenerateCompoundStatement(methodContext : MethodContext, compoundStatement: CompoundStatement) : void
    {
      def ilGenerator = methodContext.IlGenerator;
      
      ilGenerator.BeginScope();
      
      foreach (var in compoundStatement.LocalVariables)
        methodContext.AddLocalVar(var.Symbol);
      
      foreach (statement in compoundStatement.Statements)
        GenerateStatement(methodContext, statement);
        
      ilGenerator.EndScope();
    }
    
    GenerateStatement(methodContext : MethodContext, statement : Statement): void 
    {
      def ilGenerator = methodContext.IlGenerator;
      
      match (statement)
      {
        | Expression as expr => GenerateExpression(methodContext, expr.Body);
        | ReturnVoid         => ilGenerator.Emit(OperationCode.Ret);
        | Return as s =>
          GenerateExpression(methodContext, s.Value);
          ilGenerator.Emit(OperationCode.Ret);
          
        | _ => WriteLine($"Unhandlend statement! $statement");
      }
    }
    
    GenerateExpression(methodContext : MethodContext, expr : Expr) : void
    {
      def ilGenerator = methodContext.IlGenerator;
      
      match (expr)
      {
        | IntegerLiteral as e => ilGenerator.Emit(OperationCode.Ldc_I4, e.Value.Value);
        | VariableRef as e => 
          def cciVar = methodContext.GetCciLocalVar(e.Ref.Symbol);
          ilGenerator.Emit(OperationCode.Ldloc, cciVar);
          
        | ScalarAssignment as assignment =>
          GenerateExpression(methodContext, assignment.Value);
          def cciVar = methodContext.GetCciLocalVar(assignment.Ref.Symbol);
          ilGenerator.Emit(OperationCode.Stloc, cciVar);
        
        | _ => WriteLine($"Unhandled expression! $expr");
      }
    }
    
    public GetType(typeSymbol: TypeSymbol): ITypeReference
    {
      match (typeSymbol)
      {
        | IntSymbol   => _host.PlatformType.SystemInt32;
        | FloatSymbol => _host.PlatformType.SystemFloat64;
        | BoolSymbol  => _host.PlatformType.SystemBoolean;
        | VoidSymbol  => _host.PlatformType.SystemVoid;
        | _           => assert(false)
      }
    }
    
   public Dispose(): void 
    { 
      _host.Dispose()
    }
  }
}