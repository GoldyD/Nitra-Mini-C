using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Diagnostics;
using System.IO;
using System.Collections.Generic;
using System.Linq;

namespace MiniC.TestRunner
{
  [Record]
  class TestCase
  {
    public SourceFile: string;
    public ExpectedOutput: Output;
  }
  
  [Record]
  public variant Error
  {
    | ReadTestError
    | CompilerError
    | VerifyError
    | OutputError
    public Messages: list[string]
  }
  
  module TestReader
  {
    public ReadTests(dir: string, pattern: string): list[Result[TestCase, Error]]
    {
      Directory
        .GetFiles(dir, pattern)
        .ToNList()
        .Map(file => ParseOutputComment(File.ReadAllLines(file)).Map(x => TestCase(file, x)))
    }
    
    ParseOutputComment(lines: array[string]): Result[Output, Error]
    {
      def error(msg) { Result.Fail([Error.ReadTestError([msg])]) }
      
      def loop (inside, output, lines)
      {
        match (inside, lines)
        {
          | (false, "BEGIN-OUTPUT" :: rest) => loop (true, output, rest)
          | (true, "BEGIN-OUTPUT" :: _) => error("Duplicated BEGIN-OUTPUT")
          | (true, "END-OUTPUT" :: _) => Result.Ok(output)
          | (false, "END-OUTPUT" :: _) => error("END-OUTPUT without previous BEGIN-OUTPUT")
          | (true, line :: rest) => loop (true, line :: output, rest)
          | (true, []) => error("Missing END-OUTPUT marker")
          | (_, _ :: rest) => loop (inside, output, rest)
        }
      }
      loop(false, [], lines).Map(x => Output(x.Reverse().Filter(x => x.Trim() != "")))
    }
  }
  
  public variant TestStage
  {
    | Compilation
    | Verifying
    | OutputChecking
  }
  
  [Record]
  public class TestStageResult
  {
    public Stage: TestStage;
    public Duration: TimeSpan;
    public Result: Result[FakeVoid, Error];
    
    public static Time[T](stage: TestStage, f: void -> Result[T, Error]): (Result[T, Error] * TestStageResult)
    {
      def sw = Stopwatch.StartNew();
      def result = f();
      sw.Stop();
      (result, TestStageResult(stage, sw.Elapsed, result.Map(_ => FakeVoid())))
    }
  }

  [Record]
  public class TestResult
  {
    public Stages: list[TestStageResult]
  }
  
  module TestRunner
  {
    public Run(case: TestCase, outputDir: string): TestResult
    {
      def (compilationResult, compilationStage) = 
        TestStageResult.Time(
          TestStage.Compilation(), 
          () => Compiler.Compile(case.SourceFile, outputDir));
      
      def (verifyResult, verifyStage) =
        TestStageResult.Time(
          TestStage.Verifying(), 
          () => compilationResult.Bind(assemblyName => Result.Ok(FakeVoid())));
        
      TestResult([compilationStage, verifyStage])
    }
  }
  
  module Compiler
  {
    compilerPath: string = @"..\..\..\MiniC.Compiler\bin\Debug\MiniC.Compiler.exe";
    type AssemblyPath = string;
    
    public Compile(filePath: string, outputDir: string): Result[AssemblyPath, Error]
    {
      def assemblyPath = Path.Combine(outputDir, Path.GetFileNameWithoutExtension(filePath)) + ".exe";
      ProcessRunner
        .Run(compilerPath, TimeSpan.FromSeconds(10), $"-f $filePath -out $assemblyPath")
        .MapError(e => Error.CompilerError([e]))
        .Bind(output =>
        {
          match (output)
          {
            | Output([]) => Result.Ok(assemblyPath)
            | _ => Result.Fail([Error.CompilerError(output.Lines)])
          }
        });
    }
  }
}
