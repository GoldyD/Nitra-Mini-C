using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Diagnostics;
using System.IO;
using System.Collections.Generic;
using System.Linq;

namespace MiniC.TestRunner
{
  [Record]
  class TestCase
  {
    public SourceFile: FilePath;
    public ExpectedOutput: Output;
  }
  
  [Record]
  public variant Error
  {
    | ReadTestError
    | CompilerError
    | VerifyError
    | OutputError
    public Message: string;
    public override ToString(): string
    {
      def name =
        match(this)
        {
          | ReadTestError => "ReadTest"
          | CompilerError => "Compiler"
          | VerifyError => "PeVerify"
          | OutputError => "WrongOutput"
        }
      $"[$name] $Message"
    }
  }
  
  module TestReader
  {
    public ReadTests(dir: DirPath, pattern: string): Seq[Result[TestCase, Error]]
    {
      Directory
        .EnumerateFiles(dir, pattern)
        .Select(file => ParseOutputComment(File.ReadAllLines(file)).Map(x => TestCase(file, x)))
    }
    
    ParseOutputComment(lines: array[string]): Result[Output, Error]
    {
      def error(msg) { Result.Fail([Error.ReadTestError(msg)]) }
      
      def loop (inside, output, lines)
      {
        match (inside, lines)
        {
          | (false, "BEGIN-OUTPUT" :: rest) => loop (true, output, rest)
          | (true, "BEGIN-OUTPUT" :: _) => error("Duplicated BEGIN-OUTPUT")
          | (true, "END-OUTPUT" :: _) => Result.Ok(output)
          | (false, "END-OUTPUT" :: _) => error("END-OUTPUT without previous BEGIN-OUTPUT")
          | (true, line :: rest) => loop (true, line :: output, rest)
          | (true, []) => error("Missing END-OUTPUT marker")
          | (_, _ :: rest) => loop (inside, output, rest)
        }
      }
      loop(false, [], lines).Map(x => Output(x.Reverse().Filter(x => x.Trim() != "")))
    }
  }
  
  public variant TestStage
  {
    | Compile
    | Verify
    | OutputCheck
  }
  
  [Record]
  public class TestStageResult
  {
    public Stage: TestStage;
    public Duration: TimeSpan;
    public Result: Result[FakeVoid, Error];
    
    public static Time[T](stage: TestStage, f: void -> Result[T, Error]): (Result[T, Error] * TestStageResult)
    {
      def sw = Stopwatch.StartNew();
      def result = f();
      sw.Stop();
      (result, TestStageResult(stage, sw.Elapsed, result.Map(_ => FakeVoid())))
    }
  }

  [Record]
  public class TestResult
  {
    public Stages: list[TestStageResult];
    public Result: Result[FakeVoid, Error]
  }
  
  module TestRunner
  {
    public Run(case: TestCase, outputDir: DirPath): TestResult
    {
      def (compilationResult, compilationStage) = 
        TestStageResult.Time(
          TestStage.Compile(), 
          () => Compiler.Compile(case.SourceFile, outputDir));
      
      def (_, verifyStage) =
        TestStageResult.Time(
          TestStage.Verify(), 
          () => compilationResult.Bind(assemblyPath => Result.Ok(FakeVoid())));
          
      def (_, outputCheckStage) =
        TestStageResult.Time(
          TestStage.OutputCheck(),
          () => compilationResult.Bind(assemblyPath => OutputChecker.CheckAssemblyOutput(assemblyPath, case.ExpectedOutput)));
        
      def stageResults = [compilationStage, verifyStage, outputCheckStage];
      def result = stageResults.Map(_.Result).Fold(Result.Ok(FakeVoid()), (r, acc) => acc.Bind(_ => r));
      TestResult([compilationStage, verifyStage, outputCheckStage], result)
    }
  }
  
  module Compiler
  {
    compilerPath = @"..\..\..\MiniC.Compiler\bin\Debug\MiniC.Compiler.exe";
    type AssemblyPath = FilePath;
    
    public Compile(filePath: FilePath, outputDir: DirPath): Result[AssemblyPath, Error]
    {
      def assemblyPath = Path.Combine(outputDir, Path.GetFileNameWithoutExtension(filePath)) + ".exe";
      ProcessRunner
        .Run(compilerPath, TimeSpan.FromSeconds(10), $"-f $filePath -out $assemblyPath")
        .MapError(e => Error.CompilerError(e))
        .Bind(output =>
        {
          match (output)
          {
            | Output([]) => Result.Ok(assemblyPath)
            | _ => Result.Fail(output.Lines.Map(x => Error.CompilerError(x)))
          }
        });
    }
  }
  
  module OutputChecker
  {
    public CheckAssemblyOutput(assemblyPath: FilePath, expectedOutput: Output): Result[FakeVoid, Error]
    {
      ProcessRunner.Run(assemblyPath, TimeSpan.FromSeconds(10))
        .MapError(e => Error.OutputError(e))
        .Bind(actualOutput =>
          if (actualOutput != expectedOutput) 
            Result.Fail([Error.OutputError($"Expected\n\n$(expectedOutput.Lines)\n\nbut was:\n\n$(actualOutput.Lines)")])
          else 
            Result.Ok(FakeVoid()))
    }
  }
}