using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Diagnostics;
using System.IO;
using System.Collections.Generic;
using System.Linq;

namespace MiniC.TestRunner
{
  [Record]
  class TestCase
  {
    public SourceFile: FilePath;
    public ExpectedOutput: Output;
  }
  
  [Record]
  public variant Error
  {
    | ProcessRunError { Message: string }
    | ReadTestError { Message: string }
    | CompilerError { Messages: list[string] }
    | VerifyError { Message: list[string] }
    | OutputError 
      {
        Expected: Output;
        Actual: Output
      }
    
    public Format(indent: int): string
    {
      def prefix = string.Join("", Enumerable.Repeat("  ", indent).ToArray());
      def (name, lines) =
        match(this)
        {
          | ProcessRunError(msg) => ("ProcessRunError", [msg])
          | ReadTestError(msg) => ("ReadTestError", [msg])
          | CompilerError(msgs) => ("CompilerError", msgs)
          | VerifyError(msgs) => ("PeVerifyError", msgs)
          | OutputError(exp, act) => 
            {
              ("WrongOutput",
               ["Expected:"]
                .Append(exp.Lines.Map(x => prefix + x))
                .Append(["Actual:"])
                .Append(act.Lines.Map(x => prefix + x)))
            }
        }
      def lines = string.Join("\n", lines.Map(x => prefix + prefix + x));
      $"$prefix[$name]\n$lines"
    }
  }
  
  module TestReader
  {
    public ReadTests(dir: DirPath, pattern: string): Seq[Result[TestCase, Error]]
    {
      Directory
        .EnumerateFiles(dir, pattern)
        .Select(file => ParseOutputComment(File.ReadAllLines(file)).Map(x => TestCase(file, x)))
    }
    
    ParseOutputComment(lines: array[string]): Result[Output, Error]
    {
      def error(msg) { Result.Fail([Error.ReadTestError(msg)]) }
      
      def loop (inside, output, lines)
      {
        match (inside, lines)
        {
          | (false, "BEGIN-OUTPUT" :: rest) => loop (true, output, rest)
          | (true, "BEGIN-OUTPUT" :: _) => error("Duplicated BEGIN-OUTPUT")
          | (true, "END-OUTPUT" :: _) => Result.Ok(output)
          | (false, "END-OUTPUT" :: _) => error("END-OUTPUT without previous BEGIN-OUTPUT")
          | (true, line :: rest) => loop (true, line :: output, rest)
          | (true, []) => error("Missing END-OUTPUT marker")
          | (false, []) => error("No BEGIN-OUTPUT marker was found")
          | (_, _ :: rest) => loop (inside, output, rest)
        }
      }
      loop(false, [], lines.ToNList()).Map(x => Output(x.Reverse().Filter(x => !string.IsNullOrWhiteSpace(x))))
    }
  }
  
  public variant TestStage
  {
    | Compile
    | Verify
    | OutputCheck
    public override ToString(): string
    {
      match (this)
      {
        | Compile => "Compilation"
        | Verify => "PeVerify"
        | OutputCheck => "Run generated assembly"
      }
    }
  }
  
  [Record]
  public class TestStageResult
  {
    public Stage: TestStage;
    public Duration: TimeSpan;
    public Result: Result[FakeVoid, Error];
    
    public static Time[T](stage: TestStage, f: void -> Result[T, Error]): ResultWriter[T, Error, TestStageResult]
    {
      def sw = Stopwatch.StartNew();
      def result = f();
      sw.Stop();
      ResultWriter(result, [TestStageResult(stage, sw.Elapsed, result.Map(_ => FakeVoid()))])
    }
  }

  [Record]
  public class TestResult
  {
    public Result: Result[FakeVoid, Error];
    public Stages: list[TestStageResult];
  }
  
  module TestRunner
  {
    public Run(case: TestCase, outputDir: DirPath): TestResult
    {
      def result =
        TestStageResult.Time(TestStage.Compile(), () => Compiler.Compile(case.SourceFile, outputDir))
          .Bind(assembly => TestStageResult.Time(TestStage.Verify(), () => PeVerify.VerifyAssembly(assembly)))
          .Bind(assembly => TestStageResult.Time(TestStage.OutputCheck(), () => OutputChecker.CheckAssemblyOutput(assembly, case.ExpectedOutput)));
          
      TestResult(result.Result, result.Writer)
    }
  }
  
  module Compiler
  {
    compilerPath = @"..\..\..\MiniC.Compiler\bin\Debug\MiniC.Compiler.exe";
    type AssemblyPath = FilePath;
    
    public Compile(filePath: FilePath, outputDir: DirPath): Result[AssemblyPath, Error]
    {
      def assemblyPath = Path.Combine(outputDir, Path.GetFileNameWithoutExtension(filePath)) + ".exe";
      def (output, result) = ProcessRunner.Run(compilerPath, TimeSpan.FromSeconds(10), $"-f $filePath -out $assemblyPath");
      def outputResult = 
        match (output)
        {
          | Output([]) => Result.Ok(FakeVoid())
          | _ => Result.Fail([Error.CompilerError(output.Lines)])
        }
      outputResult.Bind(_ => result).Map(_ => assemblyPath)
    }
  }
  
  module OutputChecker
  {
    public CheckAssemblyOutput(assemblyPath: FilePath, expectedOutput: Output): Result[FakeVoid, Error]
    {
      def (output, result) = ProcessRunner.Run(assemblyPath, TimeSpan.FromSeconds(10));
      def outputResult =  
        if (output != expectedOutput) 
          Result.Fail([Error.OutputError(expectedOutput, output)])
        else 
          Result.Ok(FakeVoid());
      outputResult.Bind(_ => result)
    }
  }
}