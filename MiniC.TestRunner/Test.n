using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Diagnostics;
using System.IO;
using System.Collections.Generic;
using System.Linq;

namespace MiniC.TestRunner
{
  [Record]
  class TestCase
  {
    public SourceFile: string;
    public ExpectedOutput: list[string];
  }
  
  module TestReader
  {
    public ReadTests(dir: string, pattern: string, outputDir: string): list[TestCase] 
    {
      Directory
        .GetFiles(dir, pattern)
        .ToNList()
        .Map(file => TestCase(file, ParseOutputComment(File.ReadAllLines(file))))
    }
    
    ParseOutputComment(lines: array[string]): list[string]
    {
      def loop (inside, output, lines)
      {
        match (inside, lines)
        {
          | (false, "BEGIN-OUTPUT" :: rest) => loop (true, output, rest)
          | (true, "END-OUTPUT" :: _) => output
          | (_, _ :: rest) => loop (inside, output, rest)
        }
      }
      loop(false, [], lines).Reverse()
    }
  }
  
  public variant TestStage
  {
    | Compilation
    | Verifying
    | OutputChecking
  }
  
  [Record]
  public class TestStageResult
  {
    public Stage: TestStage;
    public Duration: TimeSpan;
    public Result: Result[FakeVoid];
    
    public static Time[T](stage: TestStage, f: void -> Result[T]): (Result[T] * TestStageResult)
    {
      def sw = Stopwatch.StartNew();
      def result = f();
      sw.Stop();
      (result, TestStageResult(stage, sw.Elapsed, result.Map(_ => FakeVoid())))
    }
  }

  [Record]
  public class TestResult
  {
    public Stages: list[TestStageResult]
  }
  
  module TestRunner
  {
    public Run(case: TestCase, outputDir: string): TestResult
    {
      def (compilationResult, compilationStage) = 
        TestStageResult.Time(
          TestStage.Compilation(), 
          () => Compiler.Compile(case.SourceFile, outputDir));
      
      def (verifyResult, verifyStage) =
        TestStageResult.Time(
          TestStage.Verifying(), 
          () => compilationResult.Bind(assemblyName => Result.Ok(FakeVoid())));
        
      TestResult([compilationStage, verifyStage])
    }
  }
  
  module Compiler
  {
    compilerPath: string = @"..\..\..\MiniC.Compiler\bin\Debug\MiniC.Compiler.exe";
    type AssemblyPath = string;
    
    public Compile(filePath: string, outputDir: string): Result[AssemblyPath]
    {
      def assemblyPath = Path.Combine(outputDir, Path.GetFileNameWithoutExtension(filePath)) + ".exe";
      ProcessRunner.Run(compilerPath, TimeSpan.FromSeconds(10), $"-f $filePath -out $assemblyPath")
        .Bind(outputLines => 
        {
          match (outputLines)
          {
            | [] => Result.Ok(assemblyPath)
            | _ => Result.Fail(outputLines)
          }
        });
    }
  }
}
